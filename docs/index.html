<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonnie Engine v0.1.0</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            outline: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #eee;
            font-family: monospace;
            font-size: 18px;
            z-index: 10;
            text-align: center;
        }
        #loading-bar-container {
            width: 300px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 16px;
            overflow: hidden;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00bfe6, #00d4ff);
            border-radius: 4px;
            transition: width 0.1s ease-out;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading Bonnie Engine v0.1.0...</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-status" style="margin-top: 8px; font-size: 14px; color: #888;"></div>
    </div>
    <canvas id="glcanvas" tabindex="1"></canvas>
    <script src="mq_js_bundle.js"></script>
    <script>
    (function() {
        'use strict';

        // Disable context menu on canvas
        document.getElementById('glcanvas').addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        // =============================================================================
        // WASM Memory Helpers
        // =============================================================================

        function readWasmString(ptr, len) {
            return new TextDecoder().decode(
                new Uint8Array(wasm_exports.memory.buffer, ptr, len)
            );
        }

        function writeWasmBytes(ptr, data, maxLen) {
            var len = Math.min(data.length, maxLen);
            new Uint8Array(wasm_exports.memory.buffer, ptr, len).set(
                data.subarray ? data.subarray(0, len) : data.slice(0, len)
            );
            return len;
        }

        // =============================================================================
        // File Import/Export (Level files via localStorage)
        // =============================================================================

        var FileIO = {
            import: function() {
                var input = document.createElement('input');
                input.type = 'file';
                input.accept = '.ron';
                input.onchange = function(e) {
                    var file = e.target.files[0];
                    if (file) {
                        var reader = new FileReader();
                        reader.onload = function(e) {
                            localStorage.setItem('_bonnie_import_data', e.target.result);
                            localStorage.setItem('_bonnie_import_filename', file.name);
                            localStorage.setItem('_bonnie_import_ready', 'true');
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            },

            checkImport: function() {
                return localStorage.getItem('_bonnie_import_ready') === 'true' ? 1 : 0;
            },

            getImportDataLen: function() {
                return (localStorage.getItem('_bonnie_import_data') || '').length;
            },

            getImportFilenameLen: function() {
                return (localStorage.getItem('_bonnie_import_filename') || '').length;
            },

            copyImportData: function(ptr, maxLen) {
                var data = localStorage.getItem('_bonnie_import_data') || '';
                return writeWasmBytes(ptr, new TextEncoder().encode(data), maxLen);
            },

            copyImportFilename: function(ptr, maxLen) {
                var filename = localStorage.getItem('_bonnie_import_filename') || '';
                return writeWasmBytes(ptr, new TextEncoder().encode(filename), maxLen);
            },

            clearImport: function() {
                localStorage.removeItem('_bonnie_import_ready');
                localStorage.removeItem('_bonnie_import_data');
                localStorage.removeItem('_bonnie_import_filename');
            },

            setExportData: function(ptr, len) {
                localStorage.setItem('_bonnie_export_data', readWasmString(ptr, len));
            },

            setExportFilename: function(ptr, len) {
                localStorage.setItem('_bonnie_export_filename', readWasmString(ptr, len));
            },

            triggerDownload: function() {
                var data = localStorage.getItem('_bonnie_export_data');
                var filename = localStorage.getItem('_bonnie_export_filename') || 'level.ron';
                if (data) {
                    var a = document.createElement('a');
                    a.href = URL.createObjectURL(new Blob([data], { type: 'text/plain' }));
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    localStorage.removeItem('_bonnie_export_data');
                    localStorage.removeItem('_bonnie_export_filename');
                }
            }
        };

        // =============================================================================
        // Loading UI
        // =============================================================================

        var LoadingUI = {
            setProgress: function(current, total) {
                var bar = document.getElementById('loading-bar');
                if (bar) bar.style.width = (total > 0 ? (current / total) * 100 : 0) + '%';
            },

            setStatus: function(ptr, len) {
                var el = document.getElementById('loading-status');
                if (el) el.textContent = readWasmString(ptr, len);
            },

            hide: function() {
                var el = document.getElementById('loading');
                if (el) el.style.display = 'none';
            }
        };

        // =============================================================================
        // Audio Output (Web Audio API for synthesizer playback)
        // =============================================================================

        var AudioOutput = {
            ctx: null,
            sampleRate: 44100,
            nextStartTime: 0,
            // Target buffer ahead time (50ms provides stability without too much latency)
            bufferAhead: 0.05,

            init: function(sampleRate) {
                AudioOutput.sampleRate = sampleRate;
                console.log('Audio output initialized, sample rate:', sampleRate);
            },

            ensureContext: function() {
                if (!AudioOutput.ctx) {
                    try {
                        AudioOutput.ctx = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: AudioOutput.sampleRate
                        });
                        console.log('AudioContext created, state:', AudioOutput.ctx.state);
                    } catch (e) {
                        console.error('Failed to create AudioContext:', e);
                        return null;
                    }
                }
                if (AudioOutput.ctx.state === 'suspended') {
                    AudioOutput.ctx.resume();
                }
                return AudioOutput.ctx;
            },

            write: function(leftPtr, rightPtr, len) {
                var ctx = AudioOutput.ensureContext();
                if (!ctx) return;

                var now = ctx.currentTime;

                // Copy samples from WASM memory
                var leftView = new Float32Array(wasm_exports.memory.buffer, leftPtr, len);
                var rightView = new Float32Array(wasm_exports.memory.buffer, rightPtr, len);

                // Quick check for silence (skip scheduling silent buffers)
                var maxSample = 0;
                for (var i = 0; i < len; i += 64) {
                    var s = Math.abs(leftView[i]) + Math.abs(rightView[i]);
                    if (s > maxSample) maxSample = s;
                }

                if (maxSample < 0.0001) {
                    // Silent - reset timing so next sound plays immediately
                    if (AudioOutput.nextStartTime < now) {
                        AudioOutput.nextStartTime = now;
                    }
                    return;
                }

                // Don't queue too far ahead
                if (AudioOutput.nextStartTime > now + AudioOutput.bufferAhead * 2) {
                    return;
                }

                // Create buffer and copy data
                var buffer = ctx.createBuffer(2, len, AudioOutput.sampleRate);
                buffer.getChannelData(0).set(leftView);
                buffer.getChannelData(1).set(rightView);

                var source = ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(ctx.destination);

                // Schedule: if we've fallen behind, catch up with small latency
                if (AudioOutput.nextStartTime < now) {
                    AudioOutput.nextStartTime = now + 0.005; // 5ms initial latency
                }

                source.start(AudioOutput.nextStartTime);
                AudioOutput.nextStartTime += buffer.duration;
            }
        };

        // =============================================================================
        // Asset Loading Progress (shared across textures and soundfont)
        // =============================================================================

        var AssetLoader = {
            total: 0,
            loaded: 0,

            reset: function() {
                AssetLoader.total = 0;
                AssetLoader.loaded = 0;
            },

            addTotal: function(count) {
                AssetLoader.total += count;
            },

            increment: function() {
                AssetLoader.loaded++;
                AssetLoader.updateBar();
            },

            updateBar: function() {
                var barEl = document.getElementById('loading-bar');
                if (barEl && AssetLoader.total > 0) {
                    barEl.style.width = (AssetLoader.loaded / AssetLoader.total * 100) + '%';
                }
            },

            setStatus: function(msg) {
                var statusEl = document.getElementById('loading-status');
                if (statusEl) statusEl.textContent = msg;
            }
        };

        // =============================================================================
        // Soundfont Cache (fetch raw bytes for SF2 playback)
        // =============================================================================

        var SoundfontCache = {
            data: null,
            loaded: false,
            path: 'assets/soundfonts/TimGM6mb.sf2',

            isLoaded: function() {
                return SoundfontCache.loaded ? 1 : 0;
            },

            getSize: function() {
                return SoundfontCache.data ? SoundfontCache.data.length : 0;
            },

            copyData: function(destPtr, maxLen) {
                if (!SoundfontCache.data) return 0;
                return writeWasmBytes(destPtr, SoundfontCache.data, maxLen);
            },

            prefetch: async function() {
                AssetLoader.addTotal(1); // Count soundfont as 1 asset
                try {
                    var response = await fetch(SoundfontCache.path);
                    if (!response.ok) {
                        console.warn('Soundfont not found:', SoundfontCache.path);
                        AssetLoader.increment();
                        return;
                    }
                    var buffer = await response.arrayBuffer();
                    SoundfontCache.data = new Uint8Array(buffer);
                    SoundfontCache.loaded = true;
                    AssetLoader.increment();
                    console.log('Soundfont loaded:', SoundfontCache.data.length, 'bytes');
                } catch (err) {
                    console.warn('Failed to load soundfont:', err);
                    AssetLoader.increment();
                }
            }
        };

        // =============================================================================
        // Texture Cache (parallel prefetch + native PNG decoding)
        // =============================================================================

        var TextureCache = {
            cache: {},
            complete: false,
            total: 0,
            loaded: 0,

            isComplete: function() {
                return TextureCache.complete ? 1 : 0;
            },

            getInfo: function(ptr, pathLen) {
                var tex = TextureCache.cache[readWasmString(ptr, pathLen)];
                return tex ? (tex.width << 16) | tex.height : 0;
            },

            copyData: function(pathPtr, pathLen, destPtr, maxLen) {
                var tex = TextureCache.cache[readWasmString(pathPtr, pathLen)];
                if (!tex || !tex.data) return 0;
                return writeWasmBytes(destPtr, tex.data, maxLen);
            },

            decodePng: function(blob) {
                return new Promise(function(resolve, reject) {
                    var img = new Image();
                    var url = URL.createObjectURL(blob);
                    img.onload = function() {
                        var canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        var ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve({
                            width: img.width,
                            height: img.height,
                            data: ctx.getImageData(0, 0, img.width, img.height).data
                        });
                        URL.revokeObjectURL(url);
                    };
                    img.onerror = function() {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to decode image'));
                    };
                    img.src = url;
                });
            },

            prefetchAll: async function() {
                AssetLoader.setStatus('Loading manifest...');

                try {
                    var manifest = await (await fetch('assets/textures/manifest.txt')).text();

                    // Parse manifest
                    var paths = [];
                    var currentPack = null;
                    manifest.split('\n').forEach(function(line) {
                        line = line.trim();
                        if (!line) return;
                        if (line[0] === '[' && line[line.length - 1] === ']') {
                            currentPack = line.slice(1, -1);
                        } else if (currentPack) {
                            paths.push('assets/textures/' + currentPack + '/' + line);
                        }
                    });

                    TextureCache.total = paths.length;
                    AssetLoader.addTotal(paths.length);
                    AssetLoader.setStatus('Loading assets...');

                    // Fetch and decode all in parallel
                    await Promise.all(paths.map(function(path) {
                        return fetch(path)
                            .then(function(r) { return r.blob(); })
                            .then(function(blob) { return TextureCache.decodePng(blob); })
                            .then(function(decoded) {
                                TextureCache.cache[path] = decoded;
                                TextureCache.loaded++;
                                AssetLoader.increment();
                            })
                            .catch(function() {
                                TextureCache.loaded++;
                                AssetLoader.increment();
                            });
                    }));

                    TextureCache.complete = true;
                    AssetLoader.setStatus('Starting engine...');

                } catch (err) {
                    console.error('Prefetch failed:', err);
                    TextureCache.complete = true;
                }
            }
        };

        // =============================================================================
        // Register WASM imports
        // =============================================================================

        miniquad_add_plugin({
            register_plugin: function(importObject) {
                var env = importObject.env;

                // File I/O
                env.bonnie_import_file = FileIO.import;
                env.bonnie_check_import = FileIO.checkImport;
                env.bonnie_get_import_data_len = FileIO.getImportDataLen;
                env.bonnie_get_import_filename_len = FileIO.getImportFilenameLen;
                env.bonnie_copy_import_data = FileIO.copyImportData;
                env.bonnie_copy_import_filename = FileIO.copyImportFilename;
                env.bonnie_clear_import = FileIO.clearImport;
                env.bonnie_set_export_data = FileIO.setExportData;
                env.bonnie_set_export_filename = FileIO.setExportFilename;
                env.bonnie_trigger_download = FileIO.triggerDownload;

                // Loading UI
                env.bonnie_set_loading_progress = LoadingUI.setProgress;
                env.bonnie_set_loading_status = LoadingUI.setStatus;
                env.bonnie_hide_loading = LoadingUI.hide;

                // Texture cache
                env.bonnie_is_prefetch_complete = TextureCache.isComplete;
                env.bonnie_get_cached_texture_info = TextureCache.getInfo;
                env.bonnie_copy_cached_texture = TextureCache.copyData;

                // Soundfont cache
                env.bonnie_is_soundfont_loaded = SoundfontCache.isLoaded;
                env.bonnie_get_soundfont_size = SoundfontCache.getSize;
                env.bonnie_copy_soundfont = SoundfontCache.copyData;

                // Audio output
                env.bonnie_audio_init = AudioOutput.init;
                env.bonnie_audio_write = AudioOutput.write;
            }
        });

        // =============================================================================
        // Startup
        // =============================================================================

        // Prefetch textures and soundfont in parallel, then start WASM
        Promise.all([
            TextureCache.prefetchAll(),
            SoundfontCache.prefetch()
        ]).then(function() {
            load('bonnie-engine.wasm');
        });

    })();
    </script>
</body>
</html>
